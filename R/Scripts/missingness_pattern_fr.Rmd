---
title: "Analysis of missing data patterns"
author:
  - name: Vincent Bagilet 
    url: https://www.sipa.columbia.edu/experience-sipa/sipa-profiles/vincent-bagilet
    affiliation: Columbia University
    affiliation_url: https://www.columbia.edu/
  - name: LÃ©o Zabrocki 
    url: https://www.parisschoolofeconomics.eu/en/
    affiliation: Paris School of Economics
    affiliation_url: https://www.parisschoolofeconomics.eu/en/
date: "`r Sys.Date()`"
# output:
#   html_notebook:
#     toc: no
#     theme: simplex
#     highlight: pygments
#   html_document:
#     theme: simplex
#     highlight: pygments
# ---
output: distill::distill_article
---

<style>
body {
text-align: justify}
</style>

```{r setup, include=FALSE, results='hide', warning=FALSE}
library(knitr)
opts_chunk$set(fig.path = "images/",
               cache.path = "cache/",
               cache = FALSE,
               echo = FALSE, #set to false to hide code
               message = FALSE,
               warning = FALSE,
               out.width = "85%",
               dpi = 300,
               fig.align = "center")  
```  

```{r include=FALSE}
library(tidyverse)
library(mediocrethemes)
library(lubridate)
library(leaflet)

set_mediocre_all()
```

```{r include=FALSE}
metadata_pollution <- readRDS("../Outputs/clean_metadata_pollution.RDS")
data_imputation <- readRDS("../Outputs/data_imputation.RDS")
# raw <- readRDS("../Outputs/raw_air_pollution_data.RDS")
```

In this document, we carry out a first analysis of missing data patterns in the dataset. Graphs and figures displayed in this document are purely informative and not intended for publication in their current state. Most graph are produced using loops and therefore display standard and uniform settings. Some fine tuning should be performd to produce specific graphs to be published.

First of all, we noticed that there are some issues with the dataset and therefore, for now, we restrict the dataset to observations not subject to these issues. In particular, we do not have any pollution data for 2014 nor for NO in 2015 and very few observations for PMs in 2019. These issue do not come from actual missing data but are due to issue with the package we used to access the pollution data. These data are available through the EEA interface.

```{r}
data <- data_imputation %>%  
  mutate(
    year = as.factor(year(date)),
    month = as.factor(month(date)),
    day_of_month = as.factor(day(date)),
    day_in_week = as.factor(wday(date)),
    hour = as.factor(hour(date)),
    missing = is.na(concentration)
  ) %>% 
  filter(year != 2012) %>% 
  filter(!(year %in% c(2008:2010, 2014, 2015, 2019, 2020) & pollutant == "no")) %>% 
  filter(!(year %in% c(2008:2010, 2019) & str_sub(pollutant, 1, 2) == "pm")) 
  
rm(data_imputation)
```


# Proportion of missing data in covariates

```{r fig.asp = 0.8}
table_prop_missing_covar <- data %>% 
  select(-(pollutant:averaging_time), -concentration, -(year:hour)) %>% 
  distinct() %>% 
  summarise_all(function(x) {sum(is.na(x), na.rm = TRUE)/n()}) %>% 
  pivot_longer(everything(), names_to = "variable_name", values_to = "prop_missing") %>%
  mutate(variable_name = str_replace_all(variable_name, pattern = "_", replacement = " ") %>% str_to_sentence()) 

table_prop_missing_covar %>% 
  ggplot(aes(x = prop_missing, y = variable_name)) +
  geom_col() +
  labs(title = "Proportion of missing data by covariate", x = "Proportion of missing data", y = "")

table_prop_missing_covar %>% 
  kable(col.names = c("Variable", "Proportion of missing values"))
```


In order to understand these previous results, we break down the analysis by year and represent the results in a graph, for readability.

```{r fig.asp = 1.1}
covar_missing_year <- data %>% 
  # slice(1:10000) %>%
  select(-(pollutant:averaging_time), -concentration, -(month:hour)) %>% 
  distinct() %>% 
  group_by(year) %>% 
  # mutate_all(is.na) %>% 
  summarise_all(function(x) {sum(is.na(x), na.rm = TRUE)/n()}) %>%
  pivot_longer(2:last_col(), names_to = "variable_name", values_to = "prop_missing")

covar_missing_year %>%
  ggplot() +
  geom_col(aes(y = variable_name,  x = prop_missing, fill = year), position = "dodge") +
  labs(title = "Proportion of missing data by covariate", subtitle = "By year", x = "Proportion of missing data", y = "")
```

In complete case analyses, observations for which any variable is missing are dropped. One may therefore wonder what is the share of dropped observations in a complete case analysis. We only consider variables which are potentially relevant. We also drop the UV radiation variable due to its large share of missingness.

```{r include=FALSE}
any_missing_cov <- data %>% 
  select(elevation:public_holiday, -latitude_weather_station, -longitude_weather_station, -uv_radiation) %>% 
  mutate_all(is.na) %>% 
  transmute(any_missing = (rowSums(.) > 0)) %>% 
  .$any_missing

prop_covar_missing <- sum(any_missing_cov)/length(any_missing_cov)

prop_total_missing <- sum(any_missing_cov + data$missing)/length(any_missing_cov)
```

Carrying out a complete case analysis would lead to drop `r prop_total_missing*100`% of the observations. Only considering missing covariates (and not missingness in concentration data) would lead to drop `r prop_covar_missing*100`% of the observations.

# Location of measurement stations

The stations considered are located in the 17 biggest largest in France:

```{r}
metadata_pollution %>% 
  count(city) %>% 
  kable(col.names = c("City", "Number of stations"))
```

```{r}
content <- paste("City:", metadata_pollution$city, "<br/>",
                 "Station area:", metadata_pollution$site_area, "<br/>",
                 "Opening date:", metadata_pollution$opening_date, "<br/>",
                 "Closing date:", metadata_pollution$closing_date, "<br/>",
                 "Elevation:", metadata_pollution$elevation, "<br/>")
pal <- colorFactor("Dark2", domain = metadata_pollution$site_type) 
color_in_subsample <- pal(metadata_pollution$site_type)

metadata_pollution %>%
  select(site, longitude,latitude, site_area, site_type, city) %>%
  distinct() %>%
  leaflet() %>%
  addTiles() %>%
  addProviderTiles("Esri.WorldGrayCanvas") %>%
  addCircles(popup = content, lng = ~longitude, lat = ~latitude) %>%
  addCircles(col = color_in_subsample, popup = content, lng = ~longitude, lat = ~latitude) %>%
  addLegend(pal = pal, values = ~metadata_pollution$site_type , title = "Station type")
```


# Missing data patterns in air pollution data

Here, we investigate whether missing pollutant concentration data varies across different dimentions. 

```{r include = FALSE}
share_missing <- sum(is.na(data$concentration))/nrow(data)
```

The overall share of missing values is `r share_missing`.

## Balance grahs

we first investigate whether covariates are ballanced between observations for which concentration data is missing and non missing. 

```{r}
data_clean_continuous <- data %>%
  select(elevation:elevation_weather_station, rainfall_height:school_holiday, missing)

# we compute the absolute difference between non-missing and missing observations
data_abs_difference <- data_clean_continuous %>%
  group_by(missing) %>%
  summarise_all(., ~ mean(., na.rm = TRUE)) %>%
  pivot_longer(cols = -c(missing), names_to = "variable", values_to = "average") %>%
  arrange(variable) %>%
  group_by(variable) %>%
  summarise(abs_difference = abs(average[2] - average[1]))

# we compute the standard deviation of the non-missing variables
data_sd <- data_clean_continuous %>%
  filter(missing == FALSE) %>%
  select(-missing) %>%
  summarise_all(., ~ sd(., na.rm = TRUE)) %>%
  pivot_longer(cols = everything(), names_to = "variable", values_to = "sd_non_missing")

# we create the data for the love plot : we scale the absolute difference by the sd_non_missing
data_abs_difference %>% 
  left_join(data_sd, by = c("variable")) %>%
  mutate(standardized_difference = abs_difference/sd_non_missing) %>%
  select(-c(abs_difference, sd_non_missing)) %>% 
  filter(!is.na(standardized_difference)) %>% 
  ggplot(aes(y = fct_rev(variable), x = standardized_difference)) +
  geom_vline(xintercept = 0) +
  geom_vline(xintercept = 0.1, color = "#FAB737") +
  geom_point() +
  # facet_wrap(~ city) +
  labs(title = "Covariate balance" , x = "Standardized Mean Differences", y = "")

```

It seems that most weather covariates are balanced between the two groups. Average temperature and UV radiation may however be slightly different between the two groups.

We can refine this analysis by looking separately across cities.

```{r fig.asp = 1.4}
data_clean_continuous <- data %>%
  select(elevation:elevation_weather_station, rainfall_height:school_holiday, missing, city)

# we compute the absolute difference between non-missing and missing observations
data_abs_difference <- data_clean_continuous %>%
  group_by(city, missing) %>%
  summarise_all(., ~ mean(., na.rm = TRUE)) %>%
  pivot_longer(cols = -c(city, missing), names_to = "variable", values_to = "average") %>%
  arrange(city, variable) %>%
  group_by(city, variable) %>%
  summarise(abs_difference = abs(average[2] - average[1]))

# we compute the standard deviation of the non-missing variables
data_sd <- data_clean_continuous %>%
  filter(missing == FALSE) %>%
  select(-missing) %>%
  group_by(city) %>%
  summarise_all(., ~ sd(., na.rm = TRUE)) %>%
  pivot_longer(cols = -c(city), names_to = "variable", values_to = "sd_non_missing")

# we create the data for the love plot : we scale the absolute difference by the sd_non_missing
data_abs_difference %>% 
  left_join(data_sd, by = c("city", "variable")) %>%
  mutate(standardized_difference = abs_difference/sd_non_missing) %>%
  select(-c(abs_difference, sd_non_missing)) %>% 
  filter(!is.na(standardized_difference)) %>% 
  ggplot(aes(y = fct_rev(variable), x = standardized_difference)) +
  geom_vline(xintercept = 0) +
  geom_vline(xintercept = 0.1, color = "#FAB737") +
  geom_point() +
  facet_wrap(~ city) +
  labs(title = "Covariate balance" , x = "Standardized Mean Differences", y = "")

```

### Distribution of covariates

It might also be interesting to see whether covariates have a similar distribution for observations where data is missing and when it is not.

```{r}
graph_desity_covariate <- function(df, covar) {
  df %>% 
  ggplot() + 
  geom_density(aes(x = .data[[covar]], fill = missing), alpha = 0.25) +
    labs(title = paste("Distribution of", covar), subtitle = "Comparison beween dates with missing and non missing concentrations", y = "Density", x = str_to_sentence(str_replace_all(covar, pattern = "_", replacement = " "))) 
}

continuous_var_names <- data %>% 
  select(rainfall_height:uv_radiation) %>% 
  names()
  
map(continuous_var_names, graph_desity_covariate, df = data)
```

```{r}
graph_hist_covariate <- function(df, covar) {
  covar_name <- str_replace_all(covar, pattern = "_", replacement = " ")
  
  data %>% 
  count(missing, .data[[covar]]) %>% 
  group_by(missing) %>% 
  mutate(prop = n/sum(n)) %>% 
  ggplot() +
  geom_col(aes(x = .data[[covar]], y = prop, fill = missing), position = "dodge") +
    labs(title = paste("Distribution of", covar_name), subtitle = "Comparison beween dates with missing and non missing concentrations", y = paste("Proportion in", covar_name), x = str_to_sentence(covar_name)) 
}

discrete_var_names <- data %>% 
  select(site_type, site_area, holiday_zone:hour) %>% 
  names()

map(discrete_var_names, graph_hist_covariate, df = data)
```


## Evolution of the share of missing values with the values of covariates

In this section, we investigate whether the share of missing values varies with the values of covariates. One may expect that, for extreme values of some covariates, such as temperature, wind speed or precipitation level for example, measurement instruments are more likely to be defective, leading to more missing values.


```{r}
#' Graphs describing the proportion of missing values in different groups
#'
#' Enables to plot the proportion of missing values by a number of 
#'
#' @param df A dataframe. Dataframe to analyse 
#' @param grouping_var A string. Name of the variable, in \code{df}, for which the proportion of missing values needs to be displayed
#' @param bins An integer. Number of bins to slice \code{grouping_var} in, if it is a continuous value.
#' @param facet_var A string. Name of the variable, in \code{df}, by which to facet the initial graph
#' @param y_axis_to An integer. Limit of the y axis
#' @export
#'
hist_missing_by <- function(df, variable_missing = "concentration", grouping_var, bins = 15, facet_var = NA, fill_var = NA, y_axis_to = 0.3) {
  
  grouping_var_name <- str_replace_all(grouping_var, pattern = "_", replacement = " ")
  variable_missing_name <- str_replace_all(variable_missing, pattern = "_", replacement = " ")
  
  if (!is.factor(df[[grouping_var]]) && !is.logical(df[[grouping_var]])  && !is.na(as.numeric(df[[grouping_var]]))) {
    df[[grouping_var]] <- cut_interval(as.numeric(df[[grouping_var]]), bins)
  } 
  
  graph <- df %>% 
    filter(!is.na(.data[[grouping_var]])) %>% 
    group_by_(grouping_var, facet_var, fill_var) %>%
    summarise(share_missing = sum(is.na(.data[[variable_missing]]))/n()) %>%
    arrange(share_missing) %>%
    ggplot(aes(x = .data[[grouping_var]], y = share_missing)) +
    geom_col(aes_string(fill = ifelse(!is.na(fill_var), fill_var, "NULL")), position = "dodge") +
    labs(
      title = paste("Share of missing", variable_missing_name,"data by", grouping_var_name),
      x = str_to_sentence(grouping_var_name), 
      y = paste("Share of missing", variable_missing_name,"data")
    ) 
  
  if (!is.null(y_axis_to)) {
    graph <- graph + 
      ylim(0, y_axis_to) 
  }
   
  if (!is.na(facet_var)) {
    graph <- graph +
    facet_wrap(facets = facet_var)
  } 
  
  if (substr(grouping_var, 1, 8) == "wind_dir") {
    graph <- graph +
      coord_polar() + 
      ylim(0, y_axis_to/3) 
  }
  
  
  return(graph)
}
```

### Across pollutants

```{r}
data %>%  
  hist_missing_by(grouping_var = "pollutant") 
```

One can notice that the share of missing values varies across pollutants, up to about a factor two. This higlights the potential necessity of analysing missingness patterns independently across pollutants.

### Across locations

We look weather missingness patterns vary across location characteristics.

```{r}
covariates_location <- data %>% 
  select(elevation:elevation_weather_station) %>% 
  names()

purrr::map(covariates_location, hist_missing_by, df = data, variable_missing = "concentration", bins = 10, facet_var = NA, fill = NA, y_axis_to = 0.3)

data %>%
  hist_missing_by(grouping_var = "city") +
  coord_flip()
```

### Across dates and time

We then investigate whether the share of missing values evolves with dates and time.

```{r}
covariates_time <- data %>% 
  select(public_holiday:hour) %>% 
  names()

purrr::map(covariates_time, hist_missing_by, df = data, variable_missing = "concentration", bins = 15, facet_var = NA, fill = NA, y_axis_to = 0.3)
```

Overall, we notice that, along the time dimension data almost seems to be missing at random appart from a decreasing trend in the proportion of missing data 

We also explore more closely these patterns for some variables by decomposing them by year, month or pollutant.

```{r}
data %>%  
  hist_missing_by(grouping_var = "month", facet_var = "year")

data %>%  
  hist_missing_by(grouping_var = "day_of_month", facet_var = "year")

data %>%  
  hist_missing_by(grouping_var = "day_of_month", facet_var = "month")

data %>%
  hist_missing_by(grouping_var = "day_in_week", facet_var = "year")

data %>%
  hist_missing_by(grouping_var = "day_in_week", facet_var = "month")

data %>%
  hist_missing_by(grouping_var = "hour", facet_var = "pollutant")

data %>%
  hist_missing_by(grouping_var = "year", fill_var = "pollutant")
```

### Across weather variables

```{r}
covariates_weather <- data %>% 
  select(rainfall_height:uv_radiation) %>% 
  names()

purrr::map(covariates_weather, hist_missing_by, df = data, variable_missing = "concentration", bins = 15, facet_var = NA, fill = NA, y_axis_to = 0.3)
```


### Only consider first missing value

If data is missing due to external factors, what matters might be the value of these external factor when the data started missing, *ie* potentially when the sensor first became defective. As a consequence, we plot the same graphs as before but only considering hours were the data started missing, not considering later and consecutive missing observations.

As compared to the full sample, the share of missing data decreases since we discarded many observations with missing values (every observation which was not the first observation of their period of missing data). Hence, the share of missing data is not informative in itself, only potential differences in this share across "grouping variables".

```{r}
data_first_missing <- data %>%  
  group_by(site, pollutant) %>%
  arrange(date) %>% 
  mutate( 
    first_missing = ifelse(missing == TRUE & lag(missing) == FALSE, TRUE, FALSE)
  ) %>%
  filter(first_missing | missing == FALSE)
```


```{r}
covariate_names <- data %>% 
  select(city, pollutant, elevation:hour, -ends_with("weather_station")) %>% 
  names()

purrr::map(covariate_names, hist_missing_by, df = data_first_missing, variable_missing = "concentration", bins = 10, facet_var = NA, y_axis_to = 0.1)
```

## Simultaneous missingness

In this section, we analyse whether some patterns of simultaneous missingness appear in the data. We wonder whether, for a given station, data is simultaneously missing for several pollutants or whether, for a given city, data is simultaneously missing for several stations. 

### Across pollutants

We investigate whether, in a given station, when one pollutant is missing, other pollutants are also missing. Such a missingness pattern could arise if sensors for different pollutants function jointly. 

We count the number of pollutants which are simultaneously missing for every station*date couple. Note that this analysis does not consider that an observation is missing when a given station is closed for a pollutant.

```{r}
data %>% 
  group_by(date, site) %>% 
  summarise(nb_missing = sum(missing)) %>% 
  ungroup() %>% 
  count(nb_missing) %>% 
  mutate(prop = n/sum(n)) %>% 
  kable(col.names = c("Number of pollutants with missing concentration data", "Number of dates", "Proportion"))
```

We could also investigate whether this pattern varies with various weather variables.

Now, part of the stations do not measure values for all pollutants. Thus, it is interesting to compute the proportion of pollutants measured by station for which data is missing.

```{r}
data %>% 
  # mutate(one = 1) %>% 
  group_by(date, site) %>% 
  summarise(share_missing = sum(missing)/n()) %>% 
  ungroup() %>% 
  count(share_missing) %>% 
  mutate(
    prop = n/sum(n),
    prop_if_missing = ifelse(share_missing != 0, n/(sum(n) - n[1]), NA)
  ) %>% 
  kable(col.names = c("Share of pollutants measured in the station for which concentration data is missing", "Number of dates", "Proportion", "Proportion among dates with missing observations"), caption = "In all stations")
```

Since for analyses studying the link btween air pollution and health have a particular focus on background station, we carry out the same analysis for these stations.

```{r}
data %>% 
  filter(site_type == "background") %>% 
  group_by(date, site) %>% 
  summarise(share_missing = sum(missing)/n()) %>% 
  ungroup() %>% 
  count(share_missing) %>% 
  mutate(
    prop = n/sum(n),
    prop_if_missing = ifelse(share_missing != 0, n/(sum(n) - n[1]), NA)
  ) %>% 
  kable(col.names = c("Share of pollutants measured in the station for which concentration data is missing", "Number of dates", "Proportion", "Proportion among dates with missing observations"), caption = "Only in background stations")
```

### Across stations in a city

Ultimately, analyses studying health effects of air pollution often only use one measure of concentration per city and per date. In most cases, there are several air pollution measurement stations per city. To get a unique measure of air pollution for a given city, the common practice consists in averaging pollutants concentrations from all background stations in this city. We may wonder to what extent concentration data is simultaneously missing in several stations of a given city. We therefore compute the average proportion of stations per city in which data missing.

```{r}
data %>% 
  filter(site_type == "background") %>%
  group_by(date, pollutant, city) %>% 
  summarise(share_missing = sum(missing)/n()) %>% 
  ungroup() %>% 
  count(share_missing) %>% 
  mutate(
    prop = n/sum(n),
    prop_if_missing = ifelse(share_missing != 0, n/(sum(n) - n[1]), NA)
  ) %>% 
  kable(col.names = c("Share of stations in a city for which concentration data is missing", "Number of dates", "Proportion", "Proportion among dates with missing observations"), caption = "Only in background stations")
```



## Length of periods with missing observations

In this section, we explore the length of periods with missing observations. This length may provide information on causes of missingness. Missing observations for long periods of time may be indicative of cluttered filters of broken instrument. We also explore whether the length of missingness patterns is correlated with weather variables.

First, we explore the length of missing observations by looking at the displaying, in an heatmat, for each couple station*date, whether concentration data is missing. We break this down into years for readibility. 

```{r heatmap, fig.asp=2.4}
heatmap_missingness <- function(df, y) {
  
  graph <- df %>% 
    filter(year == y) %>% 
    group_by(city) %>% 
    mutate(site_city = paste(city, as.integer(factor(site)), sep = "_")) %>% 
    ungroup()  %>%
    ggplot(aes(x = date, y = site_city, fill = missing)) +
    geom_tile() +
    # theme_minimal() +
    facet_wrap(~ pollutant) +
    scale_fill_manual(values = c("#580E3C", "#FAB737")) +
    theme(
      panel.grid.major.y = element_blank(), 
      axis.text.x = element_text(angle = 45, hjust = 1)
    ) +
    labs(title = paste("Intervals with missing concentration data pollutant in", y, sep = " "), x = "Date", y =  "Air pollution station")
    
  return(graph)
}

purrr::map(c(2008:2011, 2013:2019), heatmap_missingness, df = data)
```

Then, we look at the length of periods with missing data. First, we can either count each the number of periods with a given length (*eg* 3 periods have a length of missing data of 5 hours) or count the number of dates belonging to periods with a given length (considering the same example, 15 dates belong to a period of missing data of length 5 hours). We denote the former case "One observation per period" and the later "One observation per date".

We might be interested in looking at the length of missing periods for different pollutants. The method to measure concentration varies across pollutants and reasons for missing data may depend on the method. Particulate matter is measured with filters which can become cluttered. This could lead to rather long missing periods, with the necessary time to clean the filter. Gaseous pollutants are measured using optical methods and thus not subject to cluttered filters. 

```{r}
#give each missingness period an id (row_number of the first missing observation)
length_missing_data <- data %>% 
  mutate(row_id = row_number()) %>% 
  group_by(site, pollutant) %>%
  arrange(date) %>% 
  mutate(
    missing_period_id = ifelse(missing == TRUE & lag(missing) == FALSE, row_id, NA)
  ) %>%
  filter(missing == TRUE) %>%
  fill(missing_period_id) %>% 
  ungroup() %>% 
  select(-row_id) %>% 
  arrange(missing_period_id) %>% 
  group_by(missing_period_id, pollutant) %>% 
  mutate(length_period_missing = n()) %>% 
  ungroup()

length_missing_one_per_period <- length_missing_data %>% 
  count(missing_period_id, pollutant, name = "length_period_missing")
```

### Distribution of lengths of missing data

```{r}
graph_distrib_length <- function(df, density, bins_adjust) {
  name_df <- deparse(substitute(df))
  if (str_sub(name_df,-1L - 5) == "period") {
    per <- "period"
  } else {
    per <- "date"
  }
  
  graph <- df %>% 
    ggplot(aes(x = length_period_missing)) 
  
  if (density) {
    graph <- graph +
      geom_density(adjust = bins_adjust, fill = mediocrethemes::colors_table$base[2], alpha = 0.6)
  } else {
    graph <- graph +
      geom_histogram(bins = bins_adjust)
  }
  
    graph <- graph +
    scale_x_continuous(trans = 'log10') +
    facet_wrap(~pollutant) +
    labs(title = "Repartition of the length of missingness periods", subtitle = paste("Comparison across pollutants - One observation per", per, sep = " "), x = "Number of consecutive hours of missing data") 
    
    return(graph)
}
```

```{r}
graph_distrib_length(length_missing_one_per_period, density = FALSE, bins_adjust = 20)

graph_distrib_length(length_missing_one_per_period, density = TRUE, bins_adjust = 4)
```

As previously, we look at the distributions considering one observation per missing period and one observation per date. This later case naturally changes greatly the distribution; for instance one series of missing data of 1000 hours is only accounted for once in the former case but 1000 times in the later.

```{r}
graph_distrib_length(length_missing_data, density = FALSE, bins_adjust = 20)

graph_distrib_length(length_missing_data, density = TRUE, bins_adjust = 2)
```

We also look at the number of periods of missing data longer and shorter than a day.

```{r}
length_missing_one_per_period %>% 
  mutate(missing_longer_day = ifelse(length_period_missing > 24, TRUE, FALSE)) %>% 
  ggplot() +
  geom_histogram(aes(x = missing_longer_day), stat = "count") + 
  labs(title = "Number of periods with missing data longer/shorter than a day", subtitle = "One observation per period", x = "Missing period longer than a day", y =  "Count") 
```

```{r}
length_missing_data %>% 
  mutate(missing_longer_day = ifelse(length_period_missing > 24, TRUE, FALSE)) %>% 
  ggplot() +
  geom_histogram(aes(x = missing_longer_day), stat = "count") + 
  labs(title = "Number of periods with missing data longer/shorter than a day", subtitle = "One observation per date", x = "Missing period longer than a day", y =  "Count") 
```

### Coorelation between missingness length and weather variables

In this section, we investigate whether period length of missing data varies with weather variables. Due to the larger number of observations considered here, instead of looking at a scatter plot, we look at bivariate distribution plots

```{r}
plot_evolution_length <- function(df, var, per) {
  var_name <- str_replace_all(var, pattern = "_", replacement = " ")
  
  graph <- df %>% 
    ggplot(aes(x = .data[[var]], y = .data[["length_period_missing"]])) + 
    geom_bin2d() +
    # geom_point(alpha = 0.1) +
    scale_y_continuous(trans = 'log10') +
    labs(title = paste("Relationship between length of missingness periods and", var_name), subtitle = paste("One observation per", per), x = str_to_sentence(var_name), y =  "Length of missing period (in hours)") 
  
  if (substr(var, 1, 8) == "wind_dir") {
    graph <- graph +
      coord_polar()
  }
    
  return(graph)
}
```


```{r fig.asp=1}
purrr::map(covariates_weather, plot_evolution_length, df = length_missing_data, per = "date")
```

Then, we look into weather "values" when variables started missing. If missingness is caused by some weather feature, the weather at the time of the first missing observation would be the one to look into.

```{r fig.asp=1}
weather_length_data <- length_missing_data %>% 
  group_by(missing_period_id) %>% 
  mutate(observation_number = row_number()) %>% 
  ungroup() %>% 
  filter(observation_number == 1) 

purrr::map(covariates_weather, plot_evolution_length, df = weather_length_data, per = "period")
```





