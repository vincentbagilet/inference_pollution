---
title: "Analysis of missing data patterns (in daily data set)"
author:
  - name: Vincent Bagilet 
    url: https://www.sipa.columbia.edu/experience-sipa/sipa-profiles/vincent-bagilet
    affiliation: Columbia University
    affiliation_url: https://www.columbia.edu/
  - name: LÃ©o Zabrocki 
    url: https://www.parisschoolofeconomics.eu/en/
    affiliation: Paris School of Economics
    affiliation_url: https://www.parisschoolofeconomics.eu/en/
date: "`r Sys.Date()`"
# output:
#   html_notebook:
#     toc: no
#     theme: simplex
#     highlight: pygments
#   html_document:
#     theme: simplex
#     highlight: pygments
# ---
output: distill::distill_article
---

<style>
body {
text-align: justify}
</style>

```{r setup, include=FALSE, results='hide', warning=FALSE}
library(knitr)
opts_chunk$set(fig.path = "images/",
               cache.path = "cache/",
               cache = FALSE,
               echo = FALSE, #set to false to hide code
               message = FALSE,
               warning = FALSE,
               out.width = "85%",
               dpi = 200,
               fig.align = "center")  
```  

```{r include=FALSE}
library(tidyverse)
library(mediocrethemes)
library(lubridate)
library(leaflet)

set_mediocre_all()
```

```{r include=FALSE}
metadata_pollution <- readRDS("../Outputs/clean_metadata_pollution.RDS")
# raw <- readRDS("../Outputs/raw_air_pollution_data.RDS")
hourly_daily <- "daily" #Also need to hide/show section simultaneous missingness

if (hourly_daily == "hourly") {
  data_load <- readRDS("../Outputs/data_imputation.RDS") %>% 
    mutate(hour = as.factor(hour(date)))
} else {
  data_load <- readRDS("../Outputs/data_daily.RDS") %>% 
    mutate(site = city) 
}
```

In this document, we carry out a first analysis of missing data patterns in the `r hourly_daily` data set. Graphs and figures displayed in this document are purely informative and not intended for publication in their current state. Most graphs are produced using loops and therefore display standard and uniform settings. Some fine tuning should be performed to produce specific graphs to be published.

First of all, we noticed that there are some issues with the data set and therefore, for now, we restrict the data set to observations not subject to these issues. In particular, we do not have pollution data for NO in 2014, 2015, 2019 and 2020 and very few observations for PMs in 2019. These issue do not come from actual missing data but are due to issue with the package we used to access the pollution data. These data are available through the EEA interface.

```{r}
data <- data_load %>%  
  mutate(
    year = as.factor(year(date)),
    month = as.factor(month(date)),
    day_of_month = as.factor(day(date)),
    day_in_week = as.factor(wday(date)),
    missing = is.na(concentration)
  ) %>% 
  # filter(year != 2014) %>% 
  # filter(!(year == 2015 & pollutant == "no")) %>% 
  # filter(!(year == 2019 & str_sub(pollutant, 1, 2) == "pm")) 
# For "new" long dataset (including 2008-2012)
  filter(year != 2012) %>%
  filter(!(year %in% c(2008:2010, 2014, 2015, 2019, 2020) & pollutant == "no")) %>%
  filter(!(year %in% c(2008:2010, 2019) & str_sub(pollutant, 1, 2) == "pm")) %>% 
  select(-DIR) 
  
rm(data_load)
```


# Proportion of missing observations in covariates

We fist analyse the proportion of missing observations for each covariate.

```{r fig.asp = 0.8}
if (hourly_daily == "hourly") {
  names_prop <- data %>%
    select(-(pollutant:averaging_time), concentration, -(month:hour), -date, -missing) %>% 
    names()
} else {
  names_prop <- data %>%
    select(-(pollutant:longitude_weather_station), concentration, -(year:missing), -date) %>% 
    names()
}

table_prop_missing_covar <- data %>% 
  select(all_of(names_prop)) %>% 
  summarise_all(function(x) {sum(is.na(x), na.rm = TRUE)/n()}) %>% 
  pivot_longer(everything(), names_to = "variable_name", values_to = "prop_missing") %>%
  mutate(variable_name = str_replace_all(variable_name, pattern = "_", replacement = " ") %>% str_to_sentence()) 

table_prop_missing_covar %>% 
  ggplot(aes(x = prop_missing, y = variable_name)) +
  geom_col() +
  labs(title = "Proportion of missing data by covariate", x = "Proportion of missing data", y = "") 

table_prop_missing_covar %>% 
  arrange(variable_name) %>% 
  kable(col.names = c("Variable", "Proportion of missing values"))
```

In order to understand these previous results, we break down the analysis by year and represent the results in a graph, for readability.

```{r fig.asp = 1.1}
covar_missing_year <- data %>% 
  select(all_of(c(names_prop, "year"))) %>% 
  group_by(year) %>% 
  summarise_all(function(x) {sum(is.na(x), na.rm = TRUE)/n()}) %>%
  pivot_longer(2:last_col(), names_to = "variable_name", values_to = "prop_missing")

covar_missing_year %>%
  ggplot() +
  geom_col(aes(y = variable_name,  x = prop_missing, fill = year), position = "dodge") +
  labs(title = "Proportion of missing data by covariate", subtitle = "By year", x = "Proportion of missing data", y = "")
```

In complete case analyses, observations for which any variable is missing are dropped. One may therefore wonder what is the share of dropped observations in a complete case analysis. We only consider variables which are potentially relevant. We also drop the UV radiation variable due to its large share of missingness.

```{r include=FALSE}
if (hourly_daily == "hourly") {
  names_any <- data %>%
    select(elevation:public_holiday, -latitude_weather_station, -longitude_weather_station, -uv_radiation) %>% 
    names()
} else {
  names_any <- data %>%
    select(elevation_weather_station:public_holiday, -latitude_weather_station, -longitude_weather_station, -uv_radiation) %>% 
    names()
}

any_missing_cov <- data %>% 
  select(all_of(names_any)) %>% 
  mutate_all(is.na) %>% 
  transmute(any_missing = (rowSums(.) > 0)) %>% 
  .$any_missing

prop_covar_missing <- sum(any_missing_cov)/length(any_missing_cov)

prop_total_missing <- sum(any_missing_cov + data$missing)/length(any_missing_cov)

prop_covar_missing <- sum(any_missing_cov)/length(any_missing_cov)
```

Carrying out a complete case analysis would lead to drop `r prop_total_missing*100`% of the observations. However, one may notice that also dropping insolation duration, global radiations and rainfall duration lead the limiting factor to be concentration data.

# Location of measurement stations

The stations considered are located in the 17 biggest largest in France:

```{r}
metadata_pollution %>% 
  count(city) %>% 
  kable(col.names = c("City", "Number of stations"))
```

```{r}
content <- paste("City:", metadata_pollution$city, "<br/>",
                 "Station area:", metadata_pollution$site_area, "<br/>",
                 "Opening date:", metadata_pollution$opening_date, "<br/>",
                 "Closing date:", metadata_pollution$closing_date, "<br/>",
                 "Elevation:", metadata_pollution$elevation, "<br/>")
pal <- colorFactor("Dark2", domain = metadata_pollution$site_type) 
color_in_subsample <- pal(metadata_pollution$site_type)

metadata_pollution %>%
  select(site, longitude,latitude, site_area, site_type, city) %>%
  distinct() %>%
  leaflet() %>%
  addTiles() %>%
  addProviderTiles("Esri.WorldGrayCanvas") %>%
  addCircles(popup = content, lng = ~longitude, lat = ~latitude) %>%
  addCircles(col = color_in_subsample, popup = content, lng = ~longitude, lat = ~latitude) %>%
  addLegend(pal = pal, values = ~metadata_pollution$site_type , title = "Station type")
```


# Missing data patterns in air pollution data

Here, we investigate whether missing pollutant concentration data varies across different dimensions. 

```{r include = FALSE}
share_missing <- sum(data$missing)/nrow(data)
```

The overall share of missing air pollution observations is `r share_missing`.

## Evolution of the share of missing values with the values of covariates

In this section, we investigate whether the share of missing values varies with the values of covariates. One may expect that, for extreme values of some covariates, such as temperature, wind speed or precipitation level for example, measurement instruments are more likely to be defective, leading to more missing values.


```{r}
hist_missing_by <- function(df, variable_missing = "concentration", grouping_var, bins = 15, facet_var = NA, fill_var = NA, y_axis_to = 0.3) {
  
  grouping_var_name <- str_replace_all(grouping_var, pattern = "_", replacement = " ")
  variable_missing_name <- str_replace_all(variable_missing, pattern = "_", replacement = " ")
  facet_var_name <- str_replace_all(facet_var, pattern = "_", replacement = " ")
  
  #create bins
  if (!is.factor(df[[grouping_var]]) && !is.logical(df[[grouping_var]])  && is.numeric(df[[grouping_var]])) {
    df[[grouping_var]] <- cut_interval(as.numeric(df[[grouping_var]]), bins)
  } 
  
  graph <- df %>% 
    filter(!is.na(.data[[grouping_var]])) %>% 
    group_by_(grouping_var, facet_var, fill_var) %>%
    summarise(share_missing = sum(is.na(.data[[variable_missing]]))/n(), .groups = "drop_last") %>%
    arrange(share_missing) %>%
    ggplot(aes(x = .data[[grouping_var]], y = share_missing)) +
    geom_col(aes_string(fill = ifelse(!is.na(fill_var), fill_var, "NULL")), position = "dodge") +
    labs(
      title = paste("Share of missing", variable_missing_name,"data by", grouping_var_name),
      x = str_to_sentence(grouping_var_name), 
      y = paste("Share of missing", variable_missing_name,"data")
    ) 
  
  if (!is.null(y_axis_to)) {
    graph <- graph + 
      ylim(0, y_axis_to) 
  }
   
  if (!is.na(facet_var)) {
    graph <- graph +
      facet_wrap(facets = facet_var) +
      labs(subtitle = paste("Faceted by", facet_var_name))
  } 
  
  if (substr(grouping_var, 1, 8) == "wind_dir") {
    graph <- graph +
      coord_polar() +
      ylim(0, y_axis_to/3)
  }
  
  if (y_axis_to <= 0.1) { #works but not a "nice" condition
    graph <- graph +
      labs(subtitle = "First missing observation only")
  }
  
  if (grouping_var == "city") {
    graph <- graph +
      coord_flip()
  }
  
  return(graph)
}
```

### Across pollutants

```{r}
data %>%  
  hist_missing_by(grouping_var = "pollutant") 
```

One can notice that the share of missing values varies across pollutants, up to about a factor two. This highlights the potential necessity of analyzing missingness patterns independently across pollutants.

```{r}
data %>% 
    filter(!is.na(pollutant)) %>% 
    group_by(pollutant) %>%
    summarise(share_missing = sum(missing)/n(), .groups = "drop_last") %>% 
    kable(col.names = c("Pollutant", "Proportion missing values"))
```


### Across locations

We look whether missingness patterns vary across location characteristics.

```{r}
if (hourly_daily == "hourly") {
  covariates_location <- data %>% 
    select(city, elevation:elevation_weather_station) %>% 
    names()
} else {
  covariates_location <- data %>% 
    select(city, elevation_weather_station) %>% 
    names()
}

purrr::map(covariates_location, hist_missing_by, df = data, variable_missing = "concentration", bins = 10, facet_var = NA, fill = NA, y_axis_to = 0.3)
```

### Across dates and time

We then investigate whether the share of missing values evolves with dates and time.

```{r}
if (hourly_daily == "hourly") {
  covariates_time <- data %>% 
    select(public_holiday:hour) %>% 
    names()
} else {
  covariates_time <- data %>% 
    select(public_holiday:day_in_week) %>% 
    names()
}

purrr::map(covariates_time, hist_missing_by, df = data, variable_missing = "concentration", bins = 15, facet_var = NA, fill = NA, y_axis_to = 0.3)
```

<!-- Overall, we notice that, along the time dimension data almost seems to be missing at random apart from a decreasing trend in the proportion of missing data  -->

We also explore more closely these patterns for some variables by decomposing them by year, month or pollutant.

```{r}
data %>%  
  hist_missing_by(grouping_var = "month", facet_var = "year")

data %>%  
  hist_missing_by(grouping_var = "day_of_month", facet_var = "year")

data %>%  
  hist_missing_by(grouping_var = "day_of_month", facet_var = "month")

data %>%
  hist_missing_by(grouping_var = "day_in_week", facet_var = "year")

data %>%
  hist_missing_by(grouping_var = "day_in_week", facet_var = "month")

if (hourly_daily == "hourly") {
  data %>%
    hist_missing_by(grouping_var = "hour", facet_var = "pollutant")
} 

data %>%
  hist_missing_by(grouping_var = "year", fill_var = "pollutant")
```

### Across weather variables

```{r}
covariates_weather <- data %>% 
  select(rainfall_height:uv_radiation) %>% 
  names()

purrr::map(covariates_weather, hist_missing_by, df = data, variable_missing = "concentration", bins = 15, facet_var = NA, fill = NA, y_axis_to = 0.3)
```


### Only consider first missing value

We plot the same graphs as before but only considering hours were the data started missing, not considering later and consecutive missing observations.

As compared to the full sample, the share of missing data decreases since we discarded many observations with missing values (every observation which was not the first observation of their period of missing data). Hence, the share of missing data is not informative in itself, only potential differences in this share across "grouping variables".

```{r}
data_first_missing <- data %>%  
  group_by(site, pollutant) %>%
  arrange(date) %>% 
  mutate( 
    first_missing = ifelse(missing == TRUE & lag(missing) == FALSE, TRUE, FALSE)
  ) %>%
  filter(first_missing | missing == FALSE)
```


```{r}
if (hourly_daily == "hourly") {
  covariate_names <- data %>% 
    select(city, pollutant, elevation:hour, -ends_with("weather_station")) %>%
    names()
} else {
  covariate_names <- data %>% 
    select(city, pollutant, rainfall_height:day_in_week, -wind_direction) %>%
    names()
}

purrr::map(covariate_names, hist_missing_by, df = data_first_missing, variable_missing = "concentration", bins = 10, facet_var = NA, y_axis_to = if (hourly_daily == "hourly") {0.05} elseÂ {0.02})
```

## Balance between missing and non missing observations

### Balance graphs

We first investigate whether covariates are balanced between observations for which concentration data is missing and non missing. 

```{r}
if (hourly_daily == "hourly") {
  data_clean_continuous <- data %>%
  select(elevation:elevation_weather_station, rainfall_height:uv_radiation, missing)
} else {
  data_clean_continuous <- data %>%
  select(rainfall_height:uv_radiation, missing)
}

# we compute the absolute difference between non-missing and missing observations
data_abs_difference <- data_clean_continuous %>%
  group_by(missing) %>%
  summarise_all(., ~ mean(., na.rm = TRUE)) %>%
  pivot_longer(cols = -c(missing), names_to = "variable", values_to = "average") %>%
  arrange(variable) %>%
  group_by(variable) %>%
  summarise(abs_difference = abs(average[2] - average[1]), .groups = "drop_last")

# we compute the standard deviation of the non-missing variables
data_sd <- data_clean_continuous %>%
  filter(missing == FALSE) %>%
  select(-missing) %>%
  summarise_all(., ~ sd(., na.rm = TRUE)) %>%
  pivot_longer(cols = everything(), names_to = "variable", values_to = "sd_non_missing")

# we create the data for the love plot : we scale the absolute difference by the sd_non_missing
data_abs_difference %>% 
  left_join(data_sd, by = c("variable")) %>%
  mutate(standardized_difference = abs_difference/sd_non_missing) %>%
  select(-c(abs_difference, sd_non_missing)) %>% 
  filter(!is.na(standardized_difference)) %>% 
  ggplot(aes(y = fct_rev(variable), x = standardized_difference)) +
  geom_vline(xintercept = 0) +
  geom_vline(xintercept = 0.1, color = "#FAB737") +
  geom_point() +
  # facet_wrap(~ city) +
  labs(title = "Covariate balance when concentrationmissing and not" , x = "Standardized Mean Differences", y = "")

```

<!-- It seems that most weather covariates are balanced between the two groups. Average temperature and UV radiation may however be slightly different between the two groups. -->

We can refine this analysis by looking separately across cities.

```{r fig.asp = 1.4}
if (hourly_daily == "hourly") {
  data_clean_continuous <- data %>%
  select(elevation:uv_radiation, rainfall_height:school_holiday, missing, city)
} else {
  data_clean_continuous <- data %>%
  select(rainfall_height:uv_radiation, missing, city)
}

# we compute the absolute difference between non-missing and missing observations
data_abs_difference <- data_clean_continuous %>%
  group_by(city, missing) %>%
  summarise_all(., ~ mean(., na.rm = TRUE)) %>%
  pivot_longer(cols = -c(city, missing), names_to = "variable", values_to = "average") %>%
  arrange(city, variable) %>%
  group_by(city, variable) %>%
  summarise(abs_difference = abs(average[2] - average[1]), .groups = "drop_last")

# we compute the standard deviation of the non-missing variables
data_sd <- data_clean_continuous %>%
  filter(missing == FALSE) %>%
  select(-missing) %>%
  group_by(city) %>%
  summarise_all(., ~ sd(., na.rm = TRUE)) %>%
  pivot_longer(cols = -c(city), names_to = "variable", values_to = "sd_non_missing")

# we create the data for the love plot : we scale the absolute difference by the sd_non_missing
data_abs_difference %>% 
  left_join(data_sd, by = c("city", "variable")) %>%
  mutate(standardized_difference = abs_difference/sd_non_missing) %>%
  select(-c(abs_difference, sd_non_missing)) %>% 
  filter(!is.na(standardized_difference)) %>% 
  ggplot(aes(y = fct_rev(variable), x = standardized_difference)) +
  geom_vline(xintercept = 0) +
  geom_vline(xintercept = 0.1, color = "#FAB737") +
  geom_point() +
  facet_wrap(~ city) +
  labs(title = "Covariate balance when concentrationmissing and not", subtitle = "By city", x = "Standardized Mean Differences", y = "")

```

### Distribution of covariates

It might also be interesting to see whether covariates have a similar distribution for observations where data is missing and when it is not.

```{r}
graph_density_covariate <- function(df, covar, facet_var = NA) {
  covar_name <- str_replace_all(covar, pattern = "_", replacement = " ")
  
  
  if (str_sub(covar, 1, 14) == "wind_direction") {
    graph <- df %>% 
      ggplot() + 
      geom_density(aes(x = .data[[covar]], fill = missing), alpha = 0.25, adjust = 2) +
      coord_polar()
  } else {
    graph <- df %>% 
      ggplot() + 
      geom_density(aes(x = .data[[covar]], fill = missing), alpha = 0.25) 
  }
  
  graph <- graph +
      labs(title = paste("Distribution of", covar_name), subtitle = "Comparison between dates with missing and non missing concentrations", y = "Density", x = str_to_sentence(covar_name)) 
  
  if (!is.na(facet_var)) {
    graph <- graph +
      facet_wrap(facets = facet_var)
  } 
  
  return(graph)
}

continuous_var_names <- data %>% 
  select(rainfall_height:uv_radiation) %>% 
  names()
  
map(continuous_var_names, graph_density_covariate, df = data, facet_var = NA)
```

```{r}
graph_hist_covariate <- function(df, covar, facet_var = NA) {
  covar_name <- str_replace_all(covar, pattern = "_", replacement = " ")
  
  graph <- df %>% 
    filter(!is.na(covar)) %>% 
    group_by_("missing", covar, facet_var) %>% 
    summarise(n = n(), .groups = "drop_last") %>% 
    group_by_("missing", facet_var) %>% 
    mutate(prop = n/sum(n)) %>% 
    ggplot() +
    geom_col(aes(x = .data[[covar]], y = prop, fill = missing), position = "dodge") +
      labs(title = paste("Distribution of", covar_name), subtitle = "Comparison between dates with missing and non missing concentrations", y = paste("Proportion in", covar_name), x = str_to_sentence(covar_name)) 
  
  if (!is.na(facet_var)) {
    graph <- graph +
    facet_wrap(facets = facet_var)
  } 
  
  return(graph)
}
```

```{r}
if (hourly_daily == "hourly") {
  discrete_var_names <- data %>% 
    select(site_type, site_area, holiday_zone:hour) %>% 
    names()
} else {
  discrete_var_names <- data %>% 
    select(holiday_zone:day_in_week) %>% 
    names()
}

map(discrete_var_names, graph_hist_covariate, df = data, facet_var = NA)
```

One may also be interested in looking at these distributions by pollutant. The results are rather similar across all pollutants. We do not display them to avoid overcrowding (even more than already is) the document.

<!-- ```{r} -->
<!-- map(continuous_var_names, graph_density_covariate, df = data, facet_var = "pollutant") -->

<!-- map(discrete_var_names, graph_hist_covariate, df = data, facet_var = "pollutant") -->
<!-- ``` -->


### Last value before missing

If data is missing due to external factors, what matters might be the value of these external factors when the data started missing, *ie* potentially when the sensor first became defective. As a consequence, we look into the distribution of the covariates for the last value before a missing concentration observation.

```{r}
first_missing <- data %>% 
  group_by(site, pollutant) %>% 
  arrange(date) %>% 
  mutate(
    first_missing = ifelse(lag(missing) == FALSE & missing == TRUE, TRUE, FALSE),
  ) %>% 
  filter(first_missing | !missing) %>% 
  fill(concentration) %>% 
  ungroup()
  
map(c("concentration", continuous_var_names), graph_density_covariate, df = first_missing, facet_var = NA)
# map(c("concentration", continuous_var_names), graph_density_covariate, df = first_missing, facet_var = "pollutant")


map(discrete_var_names, graph_hist_covariate, df = first_missing, facet_var = NA)
# map(discrete_var_names, graph_hist_covariate, df = first_missing, facet_var = "pollutant")
```

For concentration, we carry the last value forward in order to see whether missing concentration data is associated with different concentration values, just before the data is missing as compared to when concentration data is not missing. We also filter out high concentration values in order to see the distribution more clearly.

```{r fig.asp = 3}
graph_density_covariate(df = filter(first_missing, concentration < 100) ,covar = "concentration") + facet_wrap(~ pollutant, ncol = 1)
```

<!-- ## Simultaneous missingness -->

<!-- In this section, we analyse whether some patterns of simultaneous missingness appear in the data. We wonder whether, for a given station, data is simultaneously missing for several pollutants or whether, for a given city, data is simultaneously missing for several stations.  -->

<!-- ### Across pollutants -->

<!-- We investigate whether, in a given station, when one pollutant is missing, other pollutants are also missing. Such a missingness pattern could arise if sensors for different pollutants function jointly.  -->

<!-- We count the number of pollutants which are simultaneously missing for every station*date couple. Note that this analysis does not consider that an observation is missing when a given station is closed for a pollutant. -->

<!-- ```{r} -->
<!-- data %>%  -->
<!--   group_by(date, site) %>%  -->
<!--   summarise(nb_missing = sum(missing), .groups = "drop_last") %>%  -->
<!--   ungroup() %>%  -->
<!--   count(nb_missing) %>%  -->
<!--   mutate(prop = n/sum(n)) %>%  -->
<!--   kable(col.names = c("Number of pollutants with missing concentration data", "Number of dates", "Proportion")) -->
<!-- ``` -->

<!-- We could also investigate whether this pattern varies with various weather variables. -->

<!-- Now, part of the stations do not measure values for all pollutants. Thus, it is interesting to compute the proportion of pollutants measured by station for which data is missing. -->

<!-- ```{r} -->
<!-- data %>%  -->
<!--   # mutate(one = 1) %>%  -->
<!--   group_by(date, site) %>%  -->
<!--   summarise(share_missing = sum(missing)/n(), .groups = "drop_last") %>%  -->
<!--   ungroup() %>%  -->
<!--   count(share_missing) %>%  -->
<!--   mutate( -->
<!--     prop = n/sum(n), -->
<!--     prop_if_missing = ifelse(share_missing != 0, n/(sum(n) - n[1]), NA) -->
<!--   ) %>%  -->
<!--   kable(col.names = c("Share of pollutants measured in the station for which concentration data is missing", "Number of dates", "Proportion", "Proportion among dates with missing observations"), caption = "In all stations") -->
<!-- ``` -->

<!-- Since for analyses studying the link between air pollution and health have a particular focus on background station, we carry out the same analysis for these stations. -->

<!-- ```{r} -->
<!-- data %>%  -->
<!--   filter(site_type == "background") %>%  -->
<!--   group_by(date, site) %>%  -->
<!--   summarise(share_missing = sum(missing)/n(), .groups = "drop_last") %>%  -->
<!--   ungroup() %>%  -->
<!--   count(share_missing) %>%  -->
<!--   mutate( -->
<!--     prop = n/sum(n), -->
<!--     prop_if_missing = ifelse(share_missing != 0, n/(sum(n) - n[1]), NA) -->
<!--   ) %>%  -->
<!--   kable(col.names = c("Share of pollutants measured in the station for which concentration data is missing", "Number of dates", "Proportion", "Proportion among dates with missing observations"), caption = "Only in background stations") -->
<!-- ``` -->

<!-- ### Across stations in a city -->

<!-- Ultimately, analyses studying health effects of air pollution often only use one measure of concentration per city and per date. In most cases, there are several air pollution measurement stations per city. To get a unique measure of air pollution for a given city, the common practice consists in averaging pollutants concentrations from all background stations in this city. We may wonder to what extent concentration data is simultaneously missing in several stations of a given city. We therefore compute the average proportion of stations per city in which data missing. -->

<!-- ```{r} -->
<!-- data %>%  -->
<!--   filter(site_type == "background") %>% -->
<!--   group_by(date, pollutant, city) %>%  -->
<!--   summarise(share_missing = sum(missing)/n(), .groups = "drop_last") %>%  -->
<!--   ungroup() %>%  -->
<!--   count(share_missing) %>%  -->
<!--   mutate( -->
<!--     prop = n/sum(n), -->
<!--     prop_if_missing = ifelse(share_missing != 0, n/(sum(n) - n[1]), NA) -->
<!--   ) %>%  -->
<!--   kable(col.names = c("Share of stations in a city for which concentration data is missing", "Number of dates", "Proportion", "Proportion among dates with missing observations"), caption = "Only in background stations") -->
<!-- ``` -->

## Length of periods with missing observations

In this section, we explore the length of periods with missing observations. This length may provide information on causes of missingness. Missing observations for long periods of time may be indicative of cluttered filters of broken instrument. We also explore whether the length of missingness patterns is correlated with weather variables.

First, we explore the length of missing observations by looking at the displaying, in an heatmap, for each couple `r if (hourly_daily == "hourly") {"station"} else {"city"}`*date, whether concentration data is missing. We break this down into years for readability. 

```{r heatmap, fig.asp = if (hourly_daily == "hourly") {2.4} else {1.2}}
heatmap_missingness <- function(df, y) {
  
  graph <- df %>% 
    filter(year == y) %>% 
    group_by(city) %>% 
    mutate(site_city = paste(city, as.integer(factor(site)), sep = "_")) %>% 
    ungroup()  %>%
    ggplot(aes(x = date, y = site_city, fill = missing)) +
    geom_tile() +
    # theme_minimal() +
    facet_wrap(~ pollutant) +
    scale_fill_manual(values = c("#580E3C", "#FAB737")) +
    theme(
      panel.grid.major.y = element_blank(), 
      axis.text.x = element_text(angle = 45, hjust = 1)
    ) +
    labs(title = paste("Intervals with missing concentration data pollutant in", y, sep = " "), x = "Date", y =  "Air pollution measurement site")
    
  return(graph)
}

purrr::map(c(2013:2019), heatmap_missingness, df = data)
# For "new" dataset
# purrr::map(c(2008:2011, 2013:2019), heatmap_missingness, df = data)
```

Then, we look at the length of periods with missing data. First, we can either count each the number of periods with a given length (*eg* 3 periods have a length of missing data of 5 hours/days) or count the number of dates belonging to periods with a given length (considering the same example, 15 dates belong to a period of missing data of length 5 hours/days). We denote the former case "One observation per period" and the later "One observation per date".

We might be interested in looking at the length of missing periods for different pollutants. The method to measure concentration varies across pollutants and reasons for missing data may depend on the method. Particulate matter is measured with filters which can become cluttered. This could lead to rather long missing periods, with the necessary time to clean the filter. Gaseous pollutants are measured using optical methods and thus not subject to cluttered filters. 

```{r}
#give each missingness period an id (row_number of the first missing observation)
length_missing_data <- data %>% 
  mutate(row_id = row_number()) %>% 
  group_by(site, pollutant) %>%
  arrange(date) %>% 
  mutate(
    missing_period_id = ifelse(missing == TRUE & lag(missing) == FALSE, row_id, NA)
  ) %>%
  filter(missing == TRUE) %>%
  fill(missing_period_id) %>% 
  ungroup() %>% 
  select(-row_id) %>% 
  arrange(missing_period_id) %>% 
  group_by(missing_period_id, pollutant) %>% 
  mutate(length_period_missing = n()) %>% 
  ungroup()

length_missing_one_per_period <- length_missing_data %>% 
  count(missing_period_id, pollutant, name = "length_period_missing")
```

### Distribution of lengths of missing data

```{r}
graph_distrib_length <- function(df, density, bins_adjust) {
  name_df <- deparse(substitute(df))
  if (str_sub(name_df,-1L - 5) == "period") {
    per <- "period"
  } else {
    per <- "date"
  }
  
  graph <- df %>% 
    ggplot(aes(x = length_period_missing)) 
  
  if (density) {
    graph <- graph +
      geom_density(adjust = bins_adjust, fill = mediocrethemes::colors_table$base[2], alpha = 0.6)
  } else {
    graph <- graph +
      geom_histogram(bins = bins_adjust)
  }
  
    graph <- graph +
    scale_x_continuous(trans = 'log10') +
    facet_wrap(~pollutant) +
    labs(title = "Distribution of the length of missingness periods", subtitle = paste("Comparison across pollutants - One observation per", per, sep = " "), x = paste("Number of consecutive", if (hourly_daily == "hourly") {"hours"} else {"days"}, "of missing data", sep = " ")) 
    
    return(graph)
}
```

```{r}
graph_distrib_length(length_missing_one_per_period, density = FALSE, bins_adjust = 20)

if (hourly_daily == "hourly") {
  graph_distrib_length(length_missing_one_per_period, density = TRUE, bins_adjust = 4)
} else {
  graph_distrib_length(length_missing_one_per_period, density = TRUE, bins_adjust = 2)
}
```

As previously, we look at the distributions considering one observation per missing period and one observation per date. This later case naturally changes greatly the distribution; for instance one series of missing data of 100 hours/days is only accounted for once in the former case but 100 times in the later.

```{r}
  graph_distrib_length(length_missing_data, density = FALSE, bins_adjust = 10)

if (hourly_daily == "hourly") {
  graph_distrib_length(length_missing_data, density = TRUE, bins_adjust = 2)
} else {
  graph_distrib_length(length_missing_data, density = TRUE, bins_adjust = 1)
}
```

```{r}
if (hourly_daily == "hourly") {
  length_missing_one_per_period %>% 
    mutate(missing_longer_day = ifelse(length_period_missing > 24, TRUE, FALSE)) %>% 
    ggplot() +
    geom_histogram(aes(x = missing_longer_day), stat = "count") + 
    labs(title = "Number of periods with missing data longer/shorter than a day", subtitle = "One observation per period", x = "Missing period longer than a day", y =  "Count") 
  
  length_missing_data %>% 
    mutate(missing_longer_day = ifelse(length_period_missing > 24, TRUE, FALSE)) %>% 
    ggplot() +
    geom_histogram(aes(x = missing_longer_day), stat = "count") + 
    labs(title = "Number of periods with missing data longer/shorter than a day", subtitle = "One observation per date", x = "Missing period longer than a day", y =  "Count") 
}
```

### Correlation between missingness length and weather variables

In this section, we investigate whether period length of missing data varies with weather variables. Due to the larger number of observations considered here, instead of looking at a scatter plot, we look at bivariate distribution plots

```{r}
plot_evolution_length <- function(df, var, per) {
  var_name <- str_replace_all(var, pattern = "_", replacement = " ")
  
  graph <- df %>% 
    ggplot(aes(x = .data[[var]], y = .data[["length_period_missing"]])) + 
    geom_bin2d() +
    # geom_point(alpha = 0.1) +
    scale_y_continuous(trans = 'log10') +
    labs(title = paste("Relationship between length of missingness periods and", var_name), subtitle = paste("One observation per", per), x = str_to_sentence(var_name), y =  paste("Length of missing period (in ", if (hourly_daily == "hourly") {"hours"} else {"days"}, ")", sep = "")) 
  
  if (substr(var, 1, 8) == "wind_dir") {
    graph <- graph +
      coord_polar()
  }
    
  return(graph)
}
```


```{r fig.asp=1}
purrr::map(covariates_weather, plot_evolution_length, df = length_missing_data, per = "date")
```

Then, we look into weather "values" when variables started missing. If missingness is caused by some weather feature, the weather at the time of the first missing observation would be the one to look into.

```{r fig.asp=1}
weather_length_data <- length_missing_data %>% 
  group_by(missing_period_id) %>% 
  mutate(observation_number = row_number()) %>% 
  ungroup() %>% 
  filter(observation_number == 1) 

purrr::map(covariates_weather, plot_evolution_length, df = weather_length_data, per = "period")
```


